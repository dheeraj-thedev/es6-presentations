<!DOCTYPE html>
<html>
<head>
    <title>Let, const, arrow functions</title>
    <meta charset="utf-8">
    <script src="//gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    <style>
        @import url(//fonts.googleapis.com/css?family=Droid+Serif);
        @import url(//fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    </style>
    <link rel="stylesheet" type="text/css" href="../../css/slides.css">
</head>
<body>
<textarea id="source">

class: left, middle
background-image: url(../../images/master-folie.png)

.title[
## Let, const, arrow functions
<br/>    
### Oleg Varaksin
#### February 2016
]
    
---
    
# Variables declared with var (1/3).
    
*Variables declared with __var__ are __hoisted__ to the top.*
    
What does it mean? Hoisting is a JavaScript's default behavior of moving all declarations
to the top of the current scope. The current scope can be the current script or the current function.
Example:
    
```js
var a = 1;
    
console.log(a);  // 1
```

The variable `a` is declared as global (as expected).

```js
if (a === 1) {
  var b = 2; 
}
    
console.log(b);  // 2
```
    
Variable `b` is inside an `if` block, but in JavaScript it doesn't create a new scope. It's declared as global too.

---
    
# Variables declared with var (2/3).
    
```js
for (var c = 0; c < 3; c++) {
  ...
}
    
console.log(c);  // 3
```
    
The variable `c` is declared in a `for` loop, but it is also lies in the global scope.

```js
function doSomething() {
  var d = 4;
}
    
console.log(d);  // ReferenceError: d is not defined
```
    
The variable `d` is declared in his own scope. It's inside a function and only function creates new scopes.
    
---
    
# Variables declared with var (3/3).
    
Another example of __hoisting__:     
    
```js
function doSomething (name) {
  if (name === 'nico') {
    var awesome = true;
  }
  return awesome;
}
    
doSomething('nico')  // <- true
doSomething('marc')  // <- undefined
```
    
Behind the scenes, the JavaScript engine changes the function to look like this
    
```js
function doSomething (name) {
  var awesome;
  if (name === 'nico') {
    awesome = true;
  }
  return awesome;
}
```
    
---
    
# Let declaration (1/2).
    
The `let` declaration syntax is the same as the syntax for `var`, but it limits the variable's scope to only the current code block.
Previous examples, but with `let`:
    
```js
let a = 1;
 
if (a === 1) {
  let b = 2; 
}
 
for (let c = 0; c < 3; c++) {
  ...
}
 
function doSomething() {
  let d = 4;
}
 
console.log(a); // 1
console.log(b); // ReferenceError: b is not defined
console.log(c); // ReferenceError: c is not defined
console.log(d); // ReferenceError: d is not defined
```
    
---
    
# Let declaration (2/2).
 
Quick quiz.

```js
let a = 2;

if (a > 1) {
  let b = a * 3;
  console.log(b);  // 6
    
  for (let i = a; i <= b; i++) {
    let j = i + 10;
    ...
  }

  let c = a + b;
  console.log(c);  // 8
}
```
    
Which variable(s) exist only inside the `if` statement, and which variable(s) exist only inside the `for` loop?
    
--
    
__Answer__: the `if` statement contains `b` and `c` block-scoped variables, and the `for` loop contains `i` and `j` block-scoped variables.
    
---
    
# Let + for.
    
The
    
---
    
# Const declaration (1/2).
    
The
    
---
    
# Const declaration (2/2).
    
The
    
---
    
# Redeclaration pitfall.
    
If an identifier has already been defined in a scope, then using the identifier in a `let` declaration
inside that scope causes an error to be thrown.
    
```js
var count = 30;
   
// Syntax error is thrown
// because count is declared twice within the same block
let count = 40;
```

But the next `let` declaration doesn't throw an error.
    
```js
var count = 30;
    
if (condition) {
  let count = 40;
}
```
    
Why? Because it creates a new variable `count` within the `if` statement block,
instead of creating `count` in the surrounding block. Inside the `if` block, this new variable shadows the global `count`,
preventing access to it until execution leaves the block.
    
---
    
# The Temporal Dead Zone (1/2).
    
The `let` and `const` declarations are not hoisted to the top of the enclosing block.
A variable declared with either cannot be accessed before the declaration. Attempting to do so results in a reference error.
    
```js
if (condition) {
  console.log(typeof value);  // ReferenceError!
  let value = "blue";         // TDZ
}
```
    
The line with `let value = "blue"` is never executed because the previous line throws an error.
But the next code snippet works without errors because `typeof` check occurs outside of the block in which `value` is declared.
    
```js    
console.log(typeof value);  // "undefined"   
if (condition) {
   let value = "blue";
}
```

There is no `value` binding ouside of the block, and `typeof` simply returns `undefined`.
    
---
    
# The Temporal Dead Zone (2/2).
    
__Again, notice the difference__:

Accessing a `let`-declared variable earlier than its `let` declaration / initialization
causes an error, whereas with `var` declarations the ordering doesn't matter.
    
```js    
{
  console.log(a);   // undefined
  console.log(b);   // ReferenceError!

  var a;
  let b;
}
```

---
    
# Arrow function
    
The 
    
---
class: center, middle, inverse
    
# That's all folks, thanks for your attention!
   
Slideshow created with [remark](https://github.com/gnab/remark).
    
</textarea>
<script>
    var slideshow = remark.create({
        highlightLanguage: 'javascript', highlightStyle: 'idea', navigation: {scroll: false}
    });
</script>
</body>
</html>