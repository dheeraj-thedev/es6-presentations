<!DOCTYPE html>
<html>
<head>
    <title>Destructuring Assignment</title>
    <meta charset="utf-8">
    <script src="//gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    <style>
        @import url(//fonts.googleapis.com/css?family=Droid+Serif);
        @import url(//fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    </style>
    <link rel="stylesheet" type="text/css" href="../../css/slides.css">
</head>
<body>
<textarea id="source">

class: left, middle
background-image: url(../../images/master-folie.png)

.title[
## ECMAScript 6 (ES2015)
## Destructuring Assignment
<br/>    
### Oleg Varaksin
#### 13.01.2015
]
    
---
    
# Tutorials.
    
* [Exploring ES6: Upgrade to the next version of JavaScript](http://exploringjs.com/)
* [ES6 Overview in 350 Bullet Points](https://ponyfoo.com/articles/es6)
* [ES6 In Depth Articles](https://hacks.mozilla.org/category/es6-in-depth/)
* [ECMAScript 2015. Let’s talk about ES6](https://medium.com/ecmascript-2015)
* [ECMAScript 6 — New Features: Overview & Comparison](http://es6-features.org)
* [JS Rocks (latest JavaScript features and tools)](http://jsrocks.org/)
* [Destruktierende Zuweisung](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destrukturierende_Zuweisung)
* [Several demos and usages for ES6 destructuring](https://gist.github.com/mikaelbr/9900818)
    
# Tooling.
    
* [JavaScript Development Environment](http://www.squarefree.com/jsenv/)
* [ES5 Console](http://jsconsole.com/)
* [ES6 Console](http://es6console.com/)
* [ES6 Fiddle](http://www.es6fiddle.net/)
* [Babel](https://babeljs.io/)
 
---
    
# What is destructuring?
    
*Destructuring is a convenient way to extract values from data stored in Objects and Arrays (also nested).
 This is an opposite operation to structuring (constructing data).*
    
There is a nice syntax for constructing data in JavaScript – an *object literal*:
    
```js
var obj = {first: 'Jane', last: 'Leo'};
```

Destructuring in ECMAScript 6 enables the same syntax for extracting data. Just as the object literal lets us create
multiple properties at the same time, the object pattern lets us extract multiple properties at the same time.
    
```js
var {first: a, last: b} = obj;
// a = 'Jane', b = 'Leo'
var [x, y] = ['Jane', 'Leo'];
// x = 'Jane', y = 'Leo'
```
    
---
    
# Object destructuring.

```js
var foo = {bar: 'pony', baz: 3};
var {bar: a, baz: b} = foo;

console.log(a)
// 'pony'
console.log(b)
// 3
```
    
ES5 equivalent
    
```js
var foo = {bar: 'pony', baz: 3};
var a = foo.bar;
var b = foo.baz;
```

---
    
# Object destructuring, shorthand notation.
    
Only for object literals: If the value of a property is provided via a variable whose name is the same as the property name,
you can omit the property name.

```js
var {x, y} = {x: 11, y: 8};
    
console.log(x)
// 11
console.log(y)
// 8  
```
    
This declaration is equivalent to:

```js
var {x: x, y: y} = {x: 11, y: 8};
```
    
---
    
# Object destructuring, nested properties.

You can also pull properties as deep as you want.
    
```js
var foo = {bar: {deep: 'pony', smile: 'lol'}};
var {bar: {deep, smile: sure}} = foo;
    
console.log(deep);
// 'pony'
console.log(sure);
// 'lol'
```

ES5 equivalent
    
```js
var foo = {bar: {deep: 'pony', smile: 'lol'}};
var deep = foo.bar.deep;
var sure = foo.bar.smile;
```
    
---

# Array destructuring.
    
Destructuring works for arrays as well. How? By using square brackets in the destructuring side of the declaration.
    
```js
var [a, b, c] = [1, 2, 3];

console.log("A is " + a + ", B is " + b + ", C is " + c);
// A is 1, B is 2, C is 3
```

The *rest* operator lets you extract the remaining elements of an array into an array.
You can only use this operator as the last part inside an array.
    
```js
var [x, ...y] = ['a', 'b', 'c'];
// x = 'a', y = ['b', 'c']
``` 

Attention: The same syntax (...) is used by the *spread* operator!
    
---
    
# Pick what you need.
    
If you destructure an object, you mention only those properties that you are interested in.
    
```js    
var {x} = {x: 7, y: 3, z: 10};
// x = 7
```

If you destructure an array, you can choose to only extract a prefix.
    
```js 
var [x, y] = ['a', 'b', 'c'];
// x = 'a', y = 'b';
```
    
You can also conveniently skip over elements that you don’t care about.

```js
var [, , a, b] = [1, 2, 3, 4, 5];
// a = 3, b = 4;
    
function f() {return [1, 2, 3];}

var [a, , b] = f();
// a = 1, b = 3;
```
    
---
    
# Mix objects and arrays.
    
We can also mix objects and arrays together and use theirs literals.

```js
var mixed = {
  one: 1, two: 2, values: [3, 4, 5]
};

var {one: a, two: b, values: [c, , e]} = mixed;

console.log(a, b, c, e);
// 1 2 3 5
```
    
The same with return value of a function:
    
```js
function mixed () {
  return {
    one: 1, two: 2, values: [3, 4, 5]
  };
}

var {one: a, two: b, values: [c, , e]} = mixed();
```

---
    
# If a part has no match (1/3).
    
If the value of a destructuring assignment isn't match, it evaluates to *undefined*.
Just like when accessing not defined properties on an object with the dot or bracket notation.
    
```js
var [x, y] = [];
    
console.log(x);  // undefined
console.log(y);  // undefined    
    
var point = {
  x: 1
};

var {x: a, y: b} = point;
    
console.log(a);  // 1
console.log(b);  // undefined
```
    
---
    
# If a part has no match (2/3).
    
Example of deep objects:
    
```js
var {
  prop1: x,
  prop2: {
    prop3: {
      nested: [ , , y]
    }
  }
} = {prop: "Hello", prop2: {prop3: {nested: ["a", "b", "c"]}}};
```

--
    
__Question__: What are the values of variables *x* and *y*?
    
--
    
```js
console.log(typeof x);  // undefined
console.log(y);         // 'c'
```
    
[ES6 Fiddle](http://www.es6fiddle.net/ijakjtid/)
    
---
    
# If a part has no match (3/3).
    
If you’re trying to access a deeply nested property of a parent that doesn’t exist, then you’ll get an exception.
    
```js
var {foo: {bar}} = {baz: 'something'};
    
// Exception: TypeError
```
    
It makes sense if you rewrite destructuring in ES5:

```js
var temp = {baz: 'something'};
var bar = temp.foo.bar;
    
// Exception: TypeError
```
    
For more complex example check the FF or Chrome console of this [ES6 Fiddle](http://www.es6fiddle.net/ijal5y3m/)
    
---
    
# Default values (1/2).
    
---
    
# Default values (2/2).
    
---
    
# Destructuring in a function's parameter list.
    
---
   
# Destructuring with computed property names.
    
---
    
# Good to know.
    
If we try to omit *var*, *let* or *const*, it will throw an error, because block code can't be a destructuring assignment.
    
```js
let point = {
  x: 1
};

{x: a} = point; // throws error
```   
  
__Solution:__ We have to wrap it in parentheses.
    
```js
let point = {
  x: 1
};

({x: a} = point);

console.log(a);
// 1
```
    
---
    
# Use cases (1/3).

---
    
# Use cases (2/3).
    
---
    
# Use cases (3/3).
    
---
class: center, middle, inverse
    
# That's all folks, thanks for your attention!
   
Slideshow created with [remark](https://github.com/gnab/remark).
    
</textarea>
<script>
    var slideshow = remark.create({
        highlightLanguage: 'javascript', highlightStyle: 'idea', navigation: {scroll: false}
    });
</script>
</body>
</html>